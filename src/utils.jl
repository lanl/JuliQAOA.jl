using SparseArrays

"""
A custom iterator to generate Dicke states, which are `n`-bit arrays with exactly `k` 1's.
"""
struct DickeIterator
    n::Int
    k::Int
    current::Int
    limit::Int
end


"""
Compute the next integer after `v` with the same number of binary 1 bits.
"""
function gospers_hack(v::Int)
    if v == 0
        return Inf
    else
        c = v & -v
        r = v + c
        c = (((r โป v) >> 2) รท c) | r
        return c
    end
end


"""
Compute the next `i-1` integers after `v` that have the same number of 1 bits in binary 
representation using Gosper's hack.
"""
function gospers_hack(v::Int, i::Int)
    ret = [v]
    for _ in 1:i-1
        push!(ret, gospers_hack(ret[end]))
    end
    return ret
end


"""
Iterator protocol for `DickeIterator`. Generates the next Dicke state in the sequence.
"""
function Base.iterate(iter::DickeIterator, state = iter.current)
    state >= iter.limit && return nothing
    next_state = gospers_hack(state)
    bit_array = digits(state, base=2, pad=iter.n)
    return bit_array, next_state
end


"""
Calculate the number of Dicke states that can be generated by the iterator.
"""
Base.length(iter::DickeIterator) = binomial(iter.n, iter.k)

"""
    dicke_states(n, k)

Iterate over all `n`-bit binary arrays with exactly `k` 1's.

The uniform superposition over these states is often referred to as "the" Dicke state 
``|D^n_k\\rangle``.

# Example
```julia-repl
julia> for state in dicke_states(3,2)
           println(state)
       end
[1, 1, 0]
[1, 0, 1]
[0, 1, 1]
```
"""
dicke_states(n, k) = DickeIterator(n, k, (1 << k) - 1, 1 << n)


"""
    states(n)

Iterate over all `n`-bit binary arrays.

# Example
```julia-repl
julia> for state in states(2)
           println(state)
       end
[0, 0]
[1, 0]
[0, 1]
[1, 1]
```
"""
states(n) = (digits(i, base=2, pad=n) for i in 0:2^n-1)

# Constants
const _XMAT = sparse([0 1; 1 0])
const _YMAT = sparse([0 -im; im 0])
