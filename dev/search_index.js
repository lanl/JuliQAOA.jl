var documenterSearchIndex = {"docs":
[{"location":"angle_finding/#Angle-Finding","page":"Angle Finding","title":"Angle Finding","text":"","category":"section"},{"location":"angle_finding/","page":"Angle Finding","title":"Angle Finding","text":"JuliQAOA uses Enzyme.jl to enable  automatic differentiation (also  referred to as \"AD\" or \"autodiff\"). In short, AD allows for calculating the gradient of a function f(x1, x2,...) in the same time as a single evaluation of f with a (roughly)  constant overhead, regardless of how many parameters f depends on.","category":"page"},{"location":"angle_finding/","page":"Angle Finding","title":"Angle Finding","text":"note: Note\nThe first time you run any gradient-based function (e.g. grad) there will likely be a delay of a few seconds while Enzyme does some precomputation and caching.","category":"page"},{"location":"angle_finding/","page":"Angle Finding","title":"Angle Finding","text":"warning: Warning\nThe first time you run grad with a General mixer (including  mixer_clique and mixer_ring) you will likely get the warning:Warning: Using fallback BLAS replacements, performance may be degradedThis is a known issue with Enzyme, and should hopefully be addressed soon. It does not indicate any incorrect results, just that things are a bit slower than they need to be until some kinks between BLAS and Enzyme are worked out.","category":"page"},{"location":"angle_finding/","page":"Angle Finding","title":"Angle Finding","text":"Pages = [\"angle_finding.md\"]","category":"page"},{"location":"angle_finding/","page":"Angle Finding","title":"Angle Finding","text":"grad(angles::Vector, mixer::Mixer, obj_vals::AbstractVector, measure::AbstractVector=obj_vals)\ngrad!(G::Vector, angles::Vector, mixer::Mixer, obj_vals::AbstractVector, measure::AbstractVector=obj_vals; flip_sign=false)\nfind_local_minimum(angles::Vector, mixer::Mixer, obj_vals::AbstractVector, measure::AbstractVector=obj_vals)\nfind_local_maximum(angles::Vector, mixer::Mixer, obj_vals::AbstractVector, measure::AbstractVector=obj_vals)","category":"page"},{"location":"angle_finding/#JuliQAOA.grad","page":"Angle Finding","title":"JuliQAOA.grad","text":"grad(angles, mixer, obj_vals)\n\nCalculate the gradient of exp_value(angles, mixer, obj_vals).\n\nCan be extended to incorporate non-standard initial state psi_0rangle and observables in the same way as exp_value.\n\nwarning: Warning\ngrad does not currently work with Grover mixers. For unconstrained problems you can use the equivalent mixer_x(n, 0:n)/2^n, and for constrained problems you can use N = binom(n,k); mixer_general(dicke_states(n,k), ones(N,N)/N). These will both five you correct results, but are slower than the Grover implementation.\n\n\n\n\n\n","category":"function"},{"location":"angle_finding/#JuliQAOA.grad!","page":"Angle Finding","title":"JuliQAOA.grad!","text":"grad!(G, angles, mixer, obj_vals; flip_sign=false)\n\nCalculate the gradient of exp_value(angles, mixer, obj_vals), storing the result in the vector G. \n\nThe optional argument flip_sign adds an overall minus sign to G, which can be necessary to switch between using grad! to identify angles which minimize or maximize exp_value.\n\nCan be extended to incorporate non-standard initial state psi_0rangle and observables in the same way as exp_value.\n\n\n\n\n\n","category":"function"},{"location":"angle_finding/#JuliQAOA.find_local_minimum","page":"Angle Finding","title":"JuliQAOA.find_local_minimum","text":"find_local_minimum(angles, mixer, obj_vals)\n\nFind beta_igamma_i which minimize the H_C defined by obj_vals, beginning at angles and doing local search with  BFGS.\n\nAngles are returned in the ranges beta_i in 0T_H_Mgamma_i in 0T_H_C, where the operator periods T are calculated with get_operator_period.\n\nCan be extended to incorporate non-standard initial state psi_0rangle and observables in the same way as exp_value.\n\n\n\n\n\n","category":"function"},{"location":"angle_finding/#JuliQAOA.find_local_maximum","page":"Angle Finding","title":"JuliQAOA.find_local_maximum","text":"find_local_maximum(angles, mixer, obj_vals)\n\nFind beta_igamma_i which maximize the H_C defined by obj_vals, beginning at angles and doing local search with  BFGS.\n\nAngles are returned in the ranges beta_i in 0T_H_Mgamma_i in 0T_H_C, where the operator periods T are calculated with get_operator_period.\n\nCan be extended to incorporate non-standard initial state psi_0rangle and observables in the same way as exp_value.\n\n\n\n\n\n","category":"function"},{"location":"angle_finding/","page":"Angle Finding","title":"Angle Finding","text":"note: Note\nWhile many optimization packages, e.g.  scipy.optimize,  Optim.jl, only include  minimization, we explicitly include both minimization and maximization. This is because  the standard trick of flipping the sign of the objective function to switch between  maximization and minimization doesn't work quite as smoothly with QAOA, as adding a  minus sign in front of H_C messess up the phases. Specifically, the fact thatexp_value(angles, mixer, obj_vals) != -exp_value(angles, mixer, -obj_vals)makes it so that beta_i gamma_i which minimize a given QAOA do not maximize  that same QAOA under the replacement H_C to -H_C. In order to avoid having to  clarify whether some angles are good for e.g. \"maximizing MaxCut\" or  \"minimizing -MaxCut\", we provide separate implementations for maximization and  minimization which avoid this sign confusion.","category":"page"},{"location":"angle_finding/","page":"Angle Finding","title":"Angle Finding","text":"find_angles_bh(p, mixer::Mixer, obj_vals, measure=obj_vals; kwargs...)\ngrover_th(p, obj_vals; max=true)","category":"page"},{"location":"angle_finding/#JuliQAOA.find_angles_bh","page":"Angle Finding","title":"JuliQAOA.find_angles_bh","text":"find_angles_bh(p, mixer, obj_vals; max=true, niter=100, file=nothing, verbose=true)\n\nFind good angles up for the QAOA defined by mixer, obj_vals up to p rounds.\n\nUses an iterative, round-by-round angle finding algorithm that combines angle extrapolation and basinhopping to find high quality angles  up to p rounds. See this paper, section \"Angle &  Threshold Finding\" for more details.\n\nOptional arguments:\n\nmax=false: determines whether the goal is to minimize or maximize exp_value\nniter=100: determines the number of basinhopping iterations\nfile=nothing: save the resulting angles and expectation values in a plain text file\nverbose=true: print a running log of the angle finding results\n\n\n\n\n\n","category":"function"},{"location":"angle_finding/#JuliQAOA.grover_th-Tuple{Any, Any}","page":"Angle Finding","title":"JuliQAOA.grover_th","text":"grover_th_ev(p, obj_vals; max=true)\n\nReturns the optimal expectation value for the Grover-Th QAOA variant introduced here. \n\nGrover-Th represent a direct port of Grover's search algorithm in the QAOA context. In other  words, the output of this function represents the expectation value at p rounds that one could recover by simply doing unstructured search for optimal states (technically it's a bit  more complicated than this, see here for a more  precise characterization). This can serve as a nice benchmark for QAOA performance, that is, QAOA should at least be able to beat unstructured search.\n\nSet max=false for minimization problems.\n\n\n\n\n\n","category":"method"},{"location":"eval/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"eval/","page":"Simulation","title":"Simulation","text":"Pages = [\"eval.md\"]","category":"page"},{"location":"eval/","page":"Simulation","title":"Simulation","text":"statevector(angles, mixer, obj_vals)\nstatevector!(sv, angles, mixer::Mixer{X}, obj_vals)\nprobabilities(angles, mixer, obj_vals)\nprobabilities!(sv, angles, mixer, obj_vals)\nexp_value(angles::Vector, mixer::Mixer, obj_vals::AbstractVector, measure::AbstractVector=obj_vals)\nexp_value!(sv, angles, mixer, obj_vals, measure)","category":"page"},{"location":"eval/#JuliQAOA.statevector-Tuple{Any, Any, Any}","page":"Simulation","title":"JuliQAOA.statevector","text":"statevector(angles, mixer, obj_vals)\n\nCalculate the QAOA statevector psi(beta gamma)rangle = e^-i beta_p H_M  e^-i gamma_p H_C dots e^-i beta_1 H_M e^-i gamma_1 H_C psi_0rangle,  where \n\nangles = beta_1 ldots beta_pgamma_1ldotsgamma_p,\nmixer = H_M,\nobj_vals = the diagonal of H_C,\n\nand psi_0rangle is the uniform superposition over mixer.feasible_states.\n\nstatevector(sv, angles, mixer, obj_vals)\n\nCalculate the QAOA statevector with the custom initial state psi_0rangle = sv.\n\nExamples\n\nusing JuliQAOA, Graphs, LinearAlgebra\n\nn = 6\n\n# 3 rounds with random angles\np = 3 \nangles = rand(2*p)\n\n# transverse field mixer\nmixer = mixer_x(n) \n\n# calculate the MaxCut cost function over all basis states on a random G(n,p) graph\ng = erdos_renyi(n, 0.5)\nobj_vals = [maxcut(g, x) for x in states(n)]\n\n# calculate the statevector (with |ψ0⟩ = uniform superposition over all states)\nstatevector(angles, mixer, obj_vals)\n\n# calculate the statevector (with |ψ0⟩ = random initial state)\nsv = rand(2^n) + rand(2^n)*im\nsv = sv/norm(sv)\nstatevector(sv, angles, mixer, obj_vals)\n\n\n\n\n\n","category":"method"},{"location":"eval/#JuliQAOA.statevector!-Tuple{Any, Any, Mixer{X}, Any}","page":"Simulation","title":"JuliQAOA.statevector!","text":"statevector!(sv, angles, mixer, obj_vals)\n\nCalculate the QAOA with psi_0rangle = sv, and store the result in sv.\n\n\n\n\n\n","category":"method"},{"location":"eval/#JuliQAOA.probabilities-Tuple{Any, Any, Any}","page":"Simulation","title":"JuliQAOA.probabilities","text":"probabilities(angles, mixer, obj_vals)\n\nCalculate the probability of observing each state in mixer.feasible_states for the QAOA defined by (angles, mixer, obj_vals), wherepsi_0rangle is the uniform  superposition over mixer.feasible_states.\n\nEquivalent to abs2.(statevector(angles, mixer, obj_vals)).\n\nprobabilities(sv, angles, mixer, obj_vals)\n\nCalculate the probability of observing each state in mixer.feasible_states for the QAOA defined by (angles, mixer, obj_vals) with psi_0rangle = sv.\n\nEquivalent to abs2.(statevector(sv. angles, mixer, obj_vals)).\n\n\n\n\n\n","category":"method"},{"location":"eval/#JuliQAOA.probabilities!-NTuple{4, Any}","page":"Simulation","title":"JuliQAOA.probabilities!","text":"probabilities!(sv, angles, mixer, obj_vals)\n\nCalculate the probability of observing each state in mixer.feasible_states for the QAOA defined by (angles, mixer, obj_vals) with psi_0rangle = sv, storing the  resulting probabilities in sv.\n\n\n\n\n\n","category":"method"},{"location":"eval/#JuliQAOA.exp_value","page":"Simulation","title":"JuliQAOA.exp_value","text":"exp_value(angles, mixer, obj_vals)\n\nCalculate langlepsi(beta gamma) H_C psi(beta gamma)rangle, where psi(beta gamma)rangle = statevector(angles, mixer, obj_vals).\n\nEquivalent to dot(obj_vals, probabilities(angles, mixer, obj_vals)).\n\nCan be modified to measure the expectation value of something other than H_C and/or  start at a non-standard psi_0rangle as follows:\n\nexp_value(angles, mixer, obj_vals, measure)\n\nCalculate langlepsi(beta gamma) H_textmeasure psi(beta gamma) rangle, where measure = diagonal terms of H_textmeasure.\n\nEquivalent to dot(measure, probabilities(angles, mixer, obj_vals)).\n\nexp_value(sv, angles, mixer, obj_vals)\n\nCalculate langlepsi(beta gamma) H_C psi(beta gamma)rangle with  psi_0rangle = sv.\n\nexp_value(sv, angles, mixer, obj_vals, measure)\n\nCalculate langlepsi(beta gamma) H_textmeasure psi(beta gamma) rangle with psi_0rangle = sv.\n\nExamples\n\nusing JuliQAOA, Graphs, LinearAlgebra\n\nn = 6\n\n# 3 rounds with random angles\np = 3 \nangles = rand(2*p)\n\n# transverse field mixer\nmixer = mixer_x(n) \n\n# calculate the MaxCut cost function over all basis states on a random G(n,p) graph\ng = erdos_renyi(n, 0.5)\nobj_vals = [maxcut(g, x) for x in states(n)]\n\n# the traditional expectation value\nexp_value(angles, mixer, obj_vals)\n\n# the probability of observing an optimal state\nmeasure = obj_vals .== maximum(obj_vals)\nexp_value(angles, mixer, obj_vals, measure)\n\n# the probability of observing an optimal state starting from a random initial state\nsv = rand(2^n) + rand(2^n)*im\nsv = sv/norm(sv)\nexp_value(sv, angles, mixer, obj_vals, measure)\n\n\n\n\n\n","category":"function"},{"location":"eval/#JuliQAOA.exp_value!-NTuple{5, Any}","page":"Simulation","title":"JuliQAOA.exp_value!","text":"exp_value!(sv, angles, mixer, obj_vals, measure)\n\nCalculate langlepsi(beta gamma) H_textmeasure psi(beta gamma) rangle with psi_0rangle = sv, storing the probabilities of observing each state in sv.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Our examples are stored as Jupyter notebooks in the examples folder on GitHub. They include:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"good_average_angles:    find a set of angles for MaxCut which, on average, work well for G(np) graphs.\n'maxcut_kconst`: test performance on MaxCut constrained to a particular Hamming weight.","category":"page"},{"location":"mixers/#Mixers","page":"Mixers","title":"Mixers","text":"","category":"section"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"Pages = [\"mixers.md\"]","category":"page"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"Mixer\nMixerType","category":"page"},{"location":"mixers/#JuliQAOA.Mixer","page":"Mixers","title":"JuliQAOA.Mixer","text":"Mixer{T<:MixerType}\n\nStores information related to the mixing Hamiltonian H_M. Fields include:\n\nfeasible_states: A collection of states over which the mixer is defined and operates.\nv, d, vinv: Eigendecomposition of the matrix representation of H_M.\nlabel: Metadata for the mixer.\nN: The number of feasible states, automatically determined by the length of the    feasible_states array.\nperiod: Period of the matrix (calculated from the eigenvalues d).\n\n\n\n\n\n","category":"type"},{"location":"mixers/#JuliQAOA.MixerType","page":"Mixers","title":"JuliQAOA.MixerType","text":"MixerType\n\nCharacterizes the type of mixer, used to determine the optimal statevector simulation  algorithm.\n\nCurrently accepted types are:\n\nX: Represents any mixer composed of a symmetric sum of Pauli X operators, including    (but not limited to) the standard transverse field mixer.\nGrover: Corresponds to the Grover mixer, which projects onto the feasible subspace of    states.\nGeneral: A placeholder for user-defined custom mixers, allowing for experimentation and    extension of the QAOA framework.\n\n\n\n\n\n","category":"type"},{"location":"mixers/#Pauli-X-Mixers","page":"Mixers","title":"Pauli X Mixers","text":"","category":"section"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"The mixer H_M = sum_i X_i is often referred to as the transverse field mixer, and was the original mixer introduced by Farhi et al.. JuliQAOA allows for the extension to arbitrary powers of X. ","category":"page"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"mixer_x(n::Int, prods::AbstractVector{Int} = [1])","category":"page"},{"location":"mixers/#JuliQAOA.mixer_x","page":"Mixers","title":"JuliQAOA.mixer_x","text":"mixer_x(n, prods=[1])\n\nCreate a mixer composed of a symmetric sum of products of Pauli X operators. \n\nprods determines which powers of X are included, and must be a list of k distinct  integers w_1w_k, 0le w_i le n. Then mixer(n, prods) returns a mixer of  the form\n\nsum_j=1^k sum_i_1  i_2 ldots  i_w_j X_i_1X_i_2cdots X_i_w_j\n\nThis is a slightly unwieldy definition, and is much easier to understand by looking at  examples\n\njulia> mixer_x(6) # = sum_i X_i\nX mixer on 6-qubit states\n\njulia> mixer_x(6, [2,3]) # = sum_{i<j} X_i X_j + sum_{i<j<k} X_i X_j X_k\nX mixer on 6-qubit states with powers [2, 3]\n\nNote that X mixer objects can be added together and given arbitrary coefficients:\n\njulia> mixer_x(6,[1]) + 0.2*mixer_x(6,[2]) + mixer_x(6, [5])/π\nX mixer on 6-qubit states with powers [1, 2, 5]\n\n\n\n\n\n","category":"function"},{"location":"mixers/#Grover-Mixer","page":"Mixers","title":"Grover Mixer","text":"","category":"section"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"The Grover mixer, originally introduced here, works for both constrained and unconstrained problems and is represented by the projector onto the feasible states: mixer_grover = Franglelangle F.","category":"page"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"The Grover mixer has the property that all states with the same objective value have the same amplitude after mixing. This property can be exploited to dramatically speed up simulating QAOA with the Grover mixer.","category":"page"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"mixer_grover(n::Int)","category":"page"},{"location":"mixers/#JuliQAOA.mixer_grover-Tuple{Int64}","page":"Mixers","title":"JuliQAOA.mixer_grover","text":"mixer_grover(n)\n\nCreate the Grover mixer over all n-qubit states.\n\nmixer_grover(n,k)\n\nCreate the Grover mixer specifically for dicke_states(n,k).\n\n\n\n\n\n","category":"method"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"note: Note\nFor unconstrained problems, mixer_grover(n) is equivalent to mixer_x(n,0:n)/2^n.  However, the underlying implementation for simulating Grover mixers is much faster than that for X mixers.","category":"page"},{"location":"mixers/#XY-Mixers","page":"Mixers","title":"XY Mixers","text":"","category":"section"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"There are two common mixers of the form XX + YY, which we refer to as the Clique and Ring mixers. Both of these preserve Hamming weight and are therefore suited for  constrained problems.","category":"page"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"mixer_clique(n::Int, k::Int; file=nothing)\nmixer_ring(n::Int, k::Int; file=nothing)","category":"page"},{"location":"mixers/#JuliQAOA.mixer_clique-Tuple{Int64, Int64}","page":"Mixers","title":"JuliQAOA.mixer_clique","text":"mixer_clique(n,k; file=nothing)\n\nCreate the Clique mixer frac12sum_ijX_i X_j + Y_i Y_j specifically for dicke_states(n,k).\n\nWorks by calculating the full 2^n times 2^n Clique mixer and then deleting rows and columns corresponding to states with Hamming weight ne k. The eigendecomposition of the resulting binomnk times binomnk matrix is then calculated and stored.\n\nCreating these mixers can take some time for larger n and k, in this case a  saving+loading location file can be provided. If file already exists, mixer_clique  will simply load the existing mixer in that location. If file does not exist,  mixer_clique will calculate the mixer and store the results at file.\n\nJuliQAOA uses JLD2 for file storage, so it is recommended (though not necessary) that filenames passed to file end in .jld2.\n\n\n\n\n\n","category":"method"},{"location":"mixers/#JuliQAOA.mixer_ring-Tuple{Int64, Int64}","page":"Mixers","title":"JuliQAOA.mixer_ring","text":"mixer_ring(n,k; file=nothing)\n\nCreate the Ring mixer frac12sum_i X_i X_i+1 + Y_i Y_i+1 specifically for dicke_states(n,k).\n\nSee mixer_clique for more information and a description of the optional file argument.\n\n\n\n\n\n","category":"method"},{"location":"mixers/#Novel-Mixers","page":"Mixers","title":"Novel Mixers","text":"","category":"section"},{"location":"mixers/","page":"Mixers","title":"Mixers","text":"mixer_general(feasible_states, m)","category":"page"},{"location":"mixers/#JuliQAOA.mixer_general-Tuple{Any, Any}","page":"Mixers","title":"JuliQAOA.mixer_general","text":"mixer_general(feasible_states, m; file=nothing, name=\"\")\n\nCreate a Mixer object from a list of feasible_states and a matrix m. \n\nOptional arguments include:\n\nfile: Location for saving the mixer\nname: A name for the mixer\n\n\n\n\n\n","category":"method"},{"location":"basics/#Basic-Use","page":"Basic Use","title":"Basic Use","text":"","category":"section"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"The core functionality of JuliQAOA is to take in a set of angles  beta_i gamma_i, a mixer H_M, and a cost function H_C, and return the  statevector","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"psi(beta gamma)rangle = e^-i beta_p H_M e^-i gamma_p H_C dots e^-i beta_1 \nH_M e^-i gamma_1 H_C psi_0rangle","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"Here is a simple example for a 6-qubit MaxCut problem:","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"using JuliQAOA, Graphs\n\nn = 6\n\n# 3 rounds with random angles\np = 3 \nangles = rand(2*p)\n\n# transverse field mixer\nmixer = mixer_x(n) \n\n# calculate the MaxCut cost function over all basis states on a random G(n,p) graph\ng = erdos_renyi(n, 0.5)\nobj_vals = [maxcut(g, x) for x in states(n)]\n\n# calculate the statevector (with |ψ0⟩ = uniform superposition over all states)\nstatevector(angles, mixer, obj_vals)","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"The statevector can then be used to calculate other quantities of interest, e.g. the  expectation value of H_C or ground state probability. See the Examples section  for more examples. ","category":"page"},{"location":"basics/#Angles","page":"Basic Use","title":"Angles","text":"","category":"section"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"For a p-round QAOA, the angles are given as a vector of length 2p, with the  beta_i values followed by gamma_i values. For example,","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"angles = [0.2, 3.1, 0.9, 1.4]","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"corresponds to a 2-round QAOA with  beta_1 = 02 beta_2 = 31 gamma_1 = 09 gamma_2 = 14. ","category":"page"},{"location":"basics/#Mixer","page":"Basic Use","title":"Mixer","text":"","category":"section"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"JuliQAOA includes several built-in mixer types, along with the ability to define your own  mixer. The standard transverse field mixer on n qubits is defined as mixer_x(n), and  returns an object of type JuliQAOA.Mixer{X} that stores all of the information about the  mixer. Mixers are discussed more on the Mixers section. ","category":"page"},{"location":"basics/#Cost-Function","page":"Basic Use","title":"Cost Function","text":"","category":"section"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"Cost functions in JuliQAOA are given in terms of a function which takes as input an array of 0's and 1's and returns a real number. For example, one could define a cost function which  measures how many adjacent bits are of opposite value like this:","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"function bitflips(x)\n    C = 0\n    for i in 1:length(x)-1\n        if x[i] != x[i+1]\n            C += 1\n        end\n    end\n    return C\nend","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"In order to simulate a QAOA with this cost function, simply evaluate it over all feasible  states (we include iterators states(n) for all computational basis states, as well as dicke_states(n,k) for all states with k ones). This is commonly referred to as a list of objective values, which we abbreviate to  obj_vals. In the case of unconstrained optimization problems, this is as straightforward  as","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"obj_vals = [bitflips(x) for x in states(n)]","category":"page"},{"location":"basics/","page":"Basic Use","title":"Basic Use","text":"See the Cost Functions section for more information.","category":"page"},{"location":"cost_funcs/#Cost-Functions","page":"Cost Functions","title":"Cost Functions","text":"","category":"section"},{"location":"cost_funcs/","page":"Cost Functions","title":"Cost Functions","text":"Pages = [\"cost_funcs.md\"]","category":"page"},{"location":"cost_funcs/","page":"Cost Functions","title":"Cost Functions","text":"maxcut(G::SimpleGraph, x::AbstractVector; weights=Dict())\nbisection(G::SimpleGraph, x::AbstractVector; weights=Dict())\ndensest_ksubgraph(G::SimpleGraph, x::AbstractVector)\nkvertex_cover(G::SimpleGraph, x::AbstractVector)\nkSAT_instance(k::Int, n::Int, m::Int)\nkSAT(instance::Array, x::Array)\nsk_model(n::Int)\nspin_energy(H, x)","category":"page"},{"location":"cost_funcs/#JuliQAOA.maxcut-Tuple{SimpleGraph, AbstractVector{T} where T}","page":"Cost Functions","title":"JuliQAOA.maxcut","text":"maxcut(G::SimpleGraph, x; weights=Dict())\n\nCalculate the number of edges cut by a partition x on graph G. \n\nweights can be provided as dictionary (i,j)=>w where i < j, specifying the weights for each edge (i,j).\n\nExample\n\njulia> using JuliQAOA, Graphs\n\njulia> g = SimpleGraph(5)\n{5, 0} undirected simple Int64 graph\n\njulia> edges = [(1,2), (1,4), (2,3), (2,5), (3,5), (4,5)];\n\njulia> for edge in edges\n           add_edge!(g, edge[1], edge[2])\n       end\n\njulia> maxcut(g, [0, 0, 1, 1, 1])\n3\n\njulia> weights = Dict((1,2)=>4,(1,4)=>2,(2,3)=>1,(2,5)=>3,(3,5)=>3,(4,5)=>1);\n\njulia> maxcut(g, [0, 1, 0, 0, 1]; weights=weights)\n9\n\n\n\n\n\n","category":"method"},{"location":"cost_funcs/#JuliQAOA.bisection-Tuple{SimpleGraph, AbstractVector{T} where T}","page":"Cost Functions","title":"JuliQAOA.bisection","text":"bisection(G::SimpleGraph, x; weights=Dict())\n\nCalculate the number of edges cut by a bisection x on graph G, and throws an error if  x is not a bisection.\n\n\n\n\n\n","category":"method"},{"location":"cost_funcs/#JuliQAOA.densest_ksubgraph-Tuple{SimpleGraph, AbstractVector{T} where T}","page":"Cost Functions","title":"JuliQAOA.densest_ksubgraph","text":"densest_ksubgraph(G::SimpleGraph, x)\n\nCalculate the number of edges contained in the subgraph of G denoted by the vertices marked in x.\n\nExample\n\njulia> using JuliQAOA, Graphs\n\njulia> g = SimpleGraph(5)\n{5, 0} undirected simple Int64 graph\n\njulia> edges = [(1,2), (1,4), (2,3), (2,5), (3,5), (4,5)];\n\njulia> for edge in edges\n           add_edge!(g, edge[1], edge[2])\n       end\n\njulia> densest_ksubgraph(g, [0, 1, 1, 0, 1])\n3\n\n\n\n\n\n","category":"method"},{"location":"cost_funcs/#JuliQAOA.kvertex_cover-Tuple{SimpleGraph, AbstractVector{T} where T}","page":"Cost Functions","title":"JuliQAOA.kvertex_cover","text":"kvertex_cover(G::SimpleGraph, x)\n\nCalculate the number of edges touching at least one node of the subgraph of G denoted by  the vertices marked in x.\n\nExample\n\njulia> using JuliQAOA, Graphs\n\njulia> g = SimpleGraph(5)\n{5, 0} undirected simple Int64 graph\n\njulia> edges = [(1,2), (1,4), (2,3), (2,5), (3,5), (4,5)];\n\njulia> for edge in edges\n           add_edge!(g, edge[1], edge[2])\n       end\n\njulia> kvertex_cover(g, [1, 0, 1, 0, 1])\n6\n\n\n\n\n\n","category":"method"},{"location":"cost_funcs/#JuliQAOA.kSAT_instance-Tuple{Int64, Int64, Int64}","page":"Cost Functions","title":"JuliQAOA.kSAT_instance","text":"kSAT_instance(k,n,m)\n\nGenerate a random k-SAT instance with n variables and m clauses.\n\nReturns a list of clauses of the form e.g. [1,-2,3], where the minus sign indicates negation. To be explicit, this clause translates as \"x[1]==1 OR x[2]==0 OR x[3]==1 for a variable assignment x. \n\n\n\n\n\n","category":"method"},{"location":"cost_funcs/#JuliQAOA.kSAT-Tuple{Array, Array}","page":"Cost Functions","title":"JuliQAOA.kSAT","text":"kSAT(instance::Array, x)\n\nEvaluate the number of satisfied clauses in a given kSAT instance for a the variable assignment x. See kSAT_instance for a description of the correct format for instances.\n\n\n\n\n\n","category":"method"},{"location":"cost_funcs/#JuliQAOA.sk_model-Tuple{Int64}","page":"Cost Functions","title":"JuliQAOA.sk_model","text":"SK_model(n)\n\nGenerate a random Sherrington-Kirkpatrick model on n qubits. \n\nThe Sherrington-Kirkpatrick model is defined by a Hamiltonian of the form\n\nH = frac1N sum_ij J_ij Z_i Z_j\n\nwhere the J_ij are sampled from a normal distribution with mean 0 and standard  deviation 1. \n\nReturns a Dict of the form (i,j)=>Jij.\n\n\n\n\n\n","category":"method"},{"location":"cost_funcs/#JuliQAOA.spin_energy-Tuple{Any, Any}","page":"Cost Functions","title":"JuliQAOA.spin_energy","text":"spin_energy(H,x)\n\nCalculate the energy of a system with Hamiltonian H and binary assignment x. \n\nThe Hamiltonian should be provided as a Dict of the coupling terms. That is, the  Hamiltonian \n\nH = c_1 Z_1 + c_23 Z_2 Z_3 + c_456 Z_4 Z_5 Z_6 + ldots\n\nwould be input as Dict((1,)=>c1, (2,3)=>c23, (4,5,6)=>c456, ...).\n\nThe binary assignment x is converted to a spin assignment via the standard 0 = ↑ = 1, 1 = ↓ = -1.\n\nExample\n\njulia> using JuliQAOA\n\njulia> H = Dict((1,)=>-1.2, (2,)=>2.7, (3,)=>1.4, (1,2)=>2.2, (1,3)=>-5.9, (1,2,3)=>-4.3);\n\njulia> spin_energy(H, [1,0,1])\n-9.9\n\n\n\n\n\n","category":"method"},{"location":"#JuliQAOA","page":"Home","title":"JuliQAOA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fast, flexible package for simulating the Quantum Alternating Operator Ansatz (QAOA).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Highlights include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"No need for circuit-level description of QAOA problems.\nExact statevector simulation with minimal memory overhead.\nWrite cost functions directly in Julia, rather than encoding as a Hamiltonian.\nNative support for both constrained and unconstrained combinatorial optimization problems.\nIncludes several built-in mixer Hamiltonians, user-defined mixers are also supported.\nRobust and extensible methods for learning good angles.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable release of JuliQAOA can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(url=\"https://github.com/lanl/JuliQAOA.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> # hit the `]` button to enter the package manager\n(@v1.9) pkg> add https://github.com/lanl/JuliQAOA.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Test that the package works by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"] test JuliQAOA","category":"page"},{"location":"#What-is-QAOA?","page":"Home","title":"What is QAOA?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Quantum Alternating Operator Ansatz (QAOA) is a quantum algorithm designed for solving  combinatorial optimization problems. It is commonly studied as a hybrid classical/quantum  heuristic, which combines quantum state evolution with classical parameter optimization.  QAOA is based on the principle of evolving a quantum state through a series of operations to  encode the solution to the optimization problem into the state of a quantum system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The algorithm uses two Hamiltonians: H_C, which encodes the cost function of the  optimization problem, and H_M, the mixing Hamiltonian, which facilitates transitions  between different states. The goal is to prepare a quantum state whose measurement will  reveal an optimal or near-optimal solution to the problem at hand. This is done by applying  alternating unitary operators corresponding to the Hamiltonians. This evolution is dictated  by the following sequence for p layers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"psi(beta gamma)rangle = e^-i beta_p H_M e^-i gamma_p H_C dots e^-i beta_1 \nH_M e^-i gamma_1 H_C psi_0rangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"The initial state psi_0rangle is usually taken as the ground state of H_M, which  in many cases is the uniform superposition of feasible solutions. beta_i and  gamma_i are the variational parameters, often referred to as angles, that are optimized classically. The objective is to choose them such that the expectation value of H_C is  either minimized or maximized, depending on the optimization problem at hand:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(minmax)_betagamma langlepsi(beta gamma) H_C psi(beta gamma)rangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"Physically, one can think of tuning the angles to promote destructive interference between  states with poor objective value and constructive interference between states with good  objective value. QAOA can also be viewed as a Trotterization of quantum annealing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QAOA was first introduced as the Quantum Approximate Optimization Algorithm by  Farhi et al., and the framework was later generalized to  the Quantum Alternating Operator Ansatz by  Hadfield et al..","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find JuliQAOA helpful in your work, please cite","category":"page"},{"location":"","page":"Home","title":"Home","text":"@inproceedings{10.1145/3624062.3624220, \n    author = {Golden, John and Baertschi, Andreas and O'Malley, Dan and Pelofske, Elijah and Eidenbenz, Stephan}, \n    title = {JuliQAOA: Fast, Flexible QAOA Simulation},\n    year = {2023}, \n    isbn = {9798400707858},\n    publisher = {Association for Computing Machinery}, \n    address = {New York, NY, USA}, \n    url = {https://doi.org/10.1145/3624062.3624220}, \n    doi = {10.1145/3624062.3624220},\n    booktitle = {Proceedings of the SC '23 Workshops of The International Conference on High Performance Computing, Network, Storage, and Analysis}, \n    pages = {1454–1459}, \n    numpages = {6}, \n    location = {Denver, CO, USA}, \n    series = {SC-W '23} }","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"A collection of utility functions used throught JuliQAOA.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Pages = [\"utils.md\"]","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"states(n)\ndicke_states(n, k)\nget_operator_period(eigvals; tol=1e-10)\nclean_angles(angles, mixer, obj_vals)","category":"page"},{"location":"utils/#JuliQAOA.states-Tuple{Any}","page":"Utilities","title":"JuliQAOA.states","text":"states(n)\n\nIterate over all n-bit binary arrays.\n\nExample\n\njulia> for state in states(2)\n           println(state)\n       end\n[0, 0]\n[1, 0]\n[0, 1]\n[1, 1]\n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliQAOA.dicke_states-Tuple{Any, Any}","page":"Utilities","title":"JuliQAOA.dicke_states","text":"dicke_states(n, k)\n\nIterate over all n-bit binary arrays with exactly k 1's.\n\nThe uniform superposition over these states is often referred to as \"the\" Dicke state  D^n_krangle.\n\nExample\n\njulia> for state in dicke_states(3,2)\n           println(state)\n       end\n[1, 1, 0]\n[1, 0, 1]\n[0, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliQAOA.get_operator_period-Tuple{Any}","page":"Utilities","title":"JuliQAOA.get_operator_period","text":"get_operator_period(eigvals; tol=1e-10)\n\nCalculate the period of the unitary transformation e^i beta mathcalO, where the  operator mathcalO has eigenvalues eigvals.\n\nIf eigvals is a list of integers, returns 2π/gcd(eigvals).  rounds  entries of eigvals to integers within tol. Returns Inf if any of the eigvals are  non-integers.\n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliQAOA.clean_angles-Tuple{Any, Any, Any}","page":"Utilities","title":"JuliQAOA.clean_angles","text":"clean_angles(angles, mixer, obj_vals)\n\nTakes angles and mods them into the ranges beta_i in 0T_H_Mgamma_i in 0T_H_C, where the operator periods T are calculated with get_operator_period.\n\n\n\n\n\n","category":"method"}]
}
